from io import BytesIO
from random import randint
import unittest

from dnastorage.codec.base_conversion import *
class base_conversion_py_test(unittest.TestCase):
    """conversion test cases."""
    def test_encoding(self):
        for i in range(2**8):
            x = convertFromBase(2,convertBase(2,i,8))
            assert x == i
            x = convertFromBase(3,convertBase(3,i,8))
            assert x == i

from dnastorage.codec.dense import *
class dense_py_test(unittest.TestCase):
    """dense codec test cases."""
    def test_dense(self):
        s = bytearray([ i for i in range(100,110) ])
        assert s == dense_decode(dense_encode(s))


from dnastorage.codec.binary import *
class binary_py_test(unittest.TestCase):
    """binary codec test cases."""

    def test_rotated_encoding(self):
        for i in range(2**8):
            assert binary_unrotate_decode(binary_rotate_encode(convertToAnyBase(2,i,8,symbols=['A','C'])))==convertToAnyBase(2,i,8,symbols=['A','C'])

from dnastorage.codec.huffman import *

class huffman_py_test(unittest.TestCase):
    """Compare table generated by HuffmanTable to the textual table here"""
    """They should match."""
    def test_tables_match(self):
        syms = [ x for x in range(256) ]
        w = [ 0.1 for x in range(256) ]
        for i in range(ord('A'),ord('z'),1):
            w[i] = 0.2
            w[0] = 0.2

        ht3 = HuffmanTable(3, ['0','1', '2'], syms, w)
        enc,dec = ht3.get_tables()

        for k in range(256):
            assert dec[ enc[k] ] == k

        for k in range(256):
            assert enc[k]==huffman_enc_table[k]

from dnastorage.codec.huffman_table import *
class huffman_table_py_tests(unittest.TestCase):
    '''Check huffman table creation logic and make sure it builds a consistent table
       under a variety of scenarios. In particular, we want to make sure our huffman
       encoder matches the huffman table creation logic.
    '''
    def test_dense_16(self):
        syms = [ x for x in range (16) ]
        ht = HuffmanTable(2, ['0','1'], syms)
        enc,dec = ht.get_tables()
        for e in dec.keys():
            assert len(e) == 4

    def test_dense_9(self): 
        syms = [ x for x in range (9) ]    
        ht = HuffmanTable(3, ['0','1', '2'], syms)
        enc,dec = ht.get_tables()
        for e in dec.keys():
            assert len(e) == 2
            
    def test_from_raw_table(self):
        syms = [ x for x in range (16) ]    
        ht = HuffmanTable(2, ['0','1'], syms)
        rt = ht.get_raw_table(True)
        ht2 = HuffmanTable.from_raw_table(rt,2,['0','1'])
        assert rt == ht2.get_raw_table(True)

    def test_single_entry_raw_table(self):
        syms = [ 1 ]
        wei = [ 1 ]
        ht = HuffmanTable(2, ['0','1'], syms, wei)
        rt = ht.get_raw_table(True)
        ht2 = HuffmanTable.from_raw_table(rt,2,['0','1'])
        assert rt == ht2.get_raw_table(True)
            

from dnastorage.codec.phys import *
class phys_py_tests(unittest.TestCase):
    ''' Check the logic for adding primers to strands and inserting mid-sequence cut sites '''
    import random
    def test_append_prepend_and_cut(self):
        cut = InsertMidSequence('AGATATAGGG',Policy=AllowAll())
        pre = PrependSequence('TAAAGGAAAAAG',CodecObj=cut,Policy=AllowAll())
        app = AppendSequence( 'CAAAATATAAAA',CodecObj=pre,Policy=AllowAll())
        app = app
    
        match = 0
        for _ in range(10000):

            while True:
                strand = [ random.choice('AGCT') for _ in range(100) ]
                strand = "".join(strand)
                if 'AGATATAGGG' not in strand:
                    break            
            
            original = strand

            strand = app.encode(strand)

            copy = [ random.choice('AGCT') for _ in range(10) ] + [ _ for _ in strand ] + [ random.choice('AGCT') for _ in range(10) ]
            copy[ random.randint(0,20) ] = random.choice('AGCT')
            copy[ random.randint(140,150) ] = random.choice('AGCT')
            copy[ random.randint(75,78) ] = random.choice('AGCT')
            copy = "".join(copy)
        
            new =  app.decode(copy)

            if new != original:
                print ("")
                print ("--",len(original)-len(new))
                if len(original)==len(new):
                    print (original)
                    print ("".join([ '|' if (x!=y) else ' ' for x,y in zip(original,new)]))
                    print (new)
                else:
                    print (original)
                    print (new)
            else:
                match += 1

        assert match / 10000 * 100 > 90.0
        #print (match / 10000.0 * 100)


from dnastorage.codec.commafreecodec import *
class commafreecodec_py_tests(unittest.TestCase):
    ''' Check the logic for comma free coding '''
    def test_commafreecodec_no_faults(self):
        cfc = CommaFreeCodewords(1000)
        x = [ randint(0,255) for x in range(1000) ]
        strand = "".join(cfc.encode(x))
        x_out = cfc.decode(strand)
        for x,x2 in zip(x,x_out):
            assert x==x2

    def test_commafreecodec_with_faults(self):
        cfc = CommaFreeCodewords(1000)
        x = [ x%256 for x in range(1000) ]
        x_enc = cfc.encode(x)
        
        x_enc.insert( 5, "".join([ random.choice('ACGT') for _ in range(1) ]))
        x_enc.insert( 600, "".join([ random.choice('ACGT') for _ in range(1) ]))

        r = 200
        x_enc[ r ] = x_enc[ r ][:-1]
        
        strand = "".join(x_enc)
        x_out = cfc.decode(strand)
        for x,x2 in zip(x,x_out):
            assert x==x2

from dnastorage.codec.block import *
class block_py_tests(unittest.TestCase):
    ''' Check the logic for breaking up blocks of the outer code into a strands for the inner code. '''
    def test_BlockToStrand(self):
        b2s = BlockToStrand(20,80,Policy=AllowAll())
        x = [ randint(0,255) for x in range(4*20) ]
        print (x)    
        r = b2s.encode( [2323,x] )
        print (r)
        index,y = b2s.decode ( [2323,r] )
        assert index == 2323
        assert x == y
        #print (index, y)
        #print (sum([ (a-b)**2 for a,b in zip(x,y) ]))    



from dnastorage.util.packetizedfile import *
from dnastorage.codec.layered import *
from dnastorage.codec.block import ReedSolomonOuterCodec
from dnastorage.codec.strand import ReedSolomonInnerCodec
from dnastorage.exceptions import *
from dnastorage.codec.commafreecodec import *
from dnastorage.codec.phys import *

class LayeredCodec_py_tests(unittest.TestCase):
    ''' Check that the  LayeredCodec is working with no faults '''
    
    def test_layered_encoder(self):
        membuff = BytesIO()
        tell = membuff.tell()
        for i in range(10000):
            membuff.write(bytearray(convertIntToBytes(i,2)))
        membuff.seek(tell,0)            
        pol = NoTolerance()

        payload=9
    
        outerECC = 70 # strands
        blockSize = payload*185 # 185 normal strands
        blockCodec = ReedSolomonOuterCodec(packetSize=blockSize,errorSymbols=70,payloadSize=payload,Policy=pol)

        blockToStrand = BlockToStrand(9,(185+70)*payload,Policy=pol)
    
        # take index into account
        # better to just say number of error symbols
        strandCodec = ReedSolomonInnerCodec(2,Policy=pol)

        codewords = CommaFreeCodewords(14)

        cut = InsertMidSequence('AGGTACCA')
        pre = PrependSequence('CAGGTACGCAGTTAGCACTC',CodecObj=cut, isPrimer=True)
        app = AppendSequence( 'CGTGGCAATATGACTACGGA',CodecObj=pre, isPrimer=True)

        flank = PrependSequence('CAGGAGAATGCCTTCCTAGG',CodecObj=app, isPrimer=True)
        flank = AppendSequence('CCTCGGTTCTTCTTGACCAG',CodecObj=flank, isPrimer=True)
    
        physCodec = flank
        pf = ReadPacketizedFilestream(membuff)
    
        enc = LayeredEncoder(pf,blockSizeInBytes=blockSize,strandSizeInBytes=payload,\
                             blockCodec=blockCodec,\
                             blockToStrandCodec=blockToStrand,\
                             strandCodec=strandCodec,\
                             strandToCodewordCodec=codewords,\
                             codewordToPhysCodec=CombineCodewords(),\
                             physCodec=physCodec)

        s = enc.dummy_encode()
        #print (s[10])
        #print (len(s),len(s[0]))

        all_strands = [ _ for _ in enc ]

        wbuff = BytesIO()
        wpf = WritePacketizedFilestream(wbuff,10000*2,blockSize)

        dec = LayeredDecoder(wpf,blockSizeInBytes=blockSize,strandSizeInBytes=payload,
                             blockCodec=blockCodec,\
                             strandCodec=strandCodec,\
                             physCodec=physCodec,\
                             physToStrandCodec=codewords,\
                             strandToBlockCodec=blockToStrand,\
                             Policy=pol)

    
        for ss in all_strands:
            for s in ss:
                dec.decode(s)

        dec._attempt_final_decoding()            
        dec.write()
        assert dec.complete
        y = 0
        while True:
            b = wbuff.read(2)
            if len(b)==0:
                break
            val = convertBytesToInt(b)
            assert val == y
            y = y+1
            
if __name__ == "__main__":
    unittest.main()
